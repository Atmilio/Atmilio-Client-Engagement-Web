const express = require('express');
const { Pool } = require('pg');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const nodemailer = require('nodemailer');
const cors = require('cors');

const app = express();
const port = 3001;

// --- Server Setup ---
app.use(express.json()); // For parsing application/json
app.use(cors()); // Allow cross-origin requests

// --- Database Connection ---
const pool = new Pool({
  user: 'your_db_user',
  host: 'localhost',
  database: 'your_db_name',
  password: 'your_db_password',
  port: 5432,
});

pool.on('error', (err) => {
  console.error('Unexpected error on idle client', err);
  process.exit(-1);
});

// Test DB connection on startup
pool.connect((err, client, done) => {
  if (err) {
    console.error('Database connection failed', err.stack);
    return;
  }
  console.log('Successfully connected to the PostgreSQL database.');
  done();
});

// --- Dummy Data Setup (for initial testing) ---
const setupDummyData = async () => {
  try {
    const client = await pool.connect();
    // Ensure tables exist before inserting data
    await client.query(`
      CREATE TABLE IF NOT EXISTS users (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        email VARCHAR(255) UNIQUE NOT NULL,
        password_hash VARCHAR(255) NOT NULL,
        role VARCHAR(50) NOT NULL CHECK (role IN ('manager', 'accountant')),
        company_id UUID
      );
      CREATE TABLE IF NOT EXISTS companies (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        name VARCHAR(255) NOT NULL,
        aum_value NUMERIC(15, 2),
        legal_entities_count INT,
        active_accountants_count INT
      );
      CREATE TABLE IF NOT EXISTS legal_entities (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        name VARCHAR(255) NOT NULL,
        company_id UUID REFERENCES companies(id)
      );
      CREATE TABLE IF NOT EXISTS accountant_assignments (
        user_id UUID REFERENCES users(id),
        legal_entity_id UUID REFERENCES legal_entities(id),
        PRIMARY KEY (user_id, legal_entity_id)
      );
      CREATE TABLE IF NOT EXISTS journal_entries (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        date DATE NOT NULL,
        legal_entity_id UUID REFERENCES legal_entities(id),
        description TEXT,
        created_by_user_id UUID REFERENCES users(id)
      );
      CREATE TABLE IF NOT EXISTS transactions (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        journal_entry_id UUID REFERENCES journal_entries(id),
        account_name VARCHAR(255) NOT NULL,
        debit NUMERIC(15, 2) DEFAULT 0,
        credit NUMERIC(15, 2) DEFAULT 0,
        CHECK (debit > 0 OR credit > 0)
      );
    `);

    // Check if dummy users exist to avoid duplicates
    const managerExists = await client.query('SELECT 1 FROM users WHERE email = $1', ['nathanjohns309@gmail.com']);
    if (managerExists.rows.length === 0) {
      const hashedPassword = await bcrypt.hash('12345', 10);
      const companyId = (await client.query('INSERT INTO companies (name) VALUES ($1) RETURNING id', ['Investran Competitor Corp.'])).rows[0].id;

      await client.query(
        'INSERT INTO users (email, password_hash, role, company_id) VALUES ($1, $2, $3, $4)',
        ['nathanjohns309@gmail.com', hashedPassword, 'manager', companyId]
      );
      
      const accountantPassword = await bcrypt.hash('54321', 10);
      await client.query(
        'INSERT INTO users (email, password_hash, role, company_id) VALUES ($1, $2, $3, $4)',
        ['accountant@atmilio.com', accountantPassword, 'accountant', companyId]
      );

      console.log('Dummy users and company created successfully.');
    }
    client.release();
  } catch (err) {
    console.error('Error setting up dummy data:', err);
  }
};
setupDummyData();

// --- Middleware for Protected Routes ---
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (token == null) return res.sendStatus(401);

  jwt.verify(token, 'YOUR_SECRET_KEY', (err, user) => {
    if (err) return res.sendStatus(403);
    req.user = user;
    next();
  });
};

const authorizeRole = (role) => {
  return (req, res, next) => {
    if (req.user.role !== role) {
      return res.status(403).json({ message: 'Access denied' });
    }
    next();
  };
};

// --- Authentication API ---
// Generate a 6-digit OTP
const generateOtp = () => Math.floor(100000 + Math.random() * 900000).toString();

// NodeMailer for sending emails (for OTPs)
const transporter = nodemailer.createTransport({
  service: 'Gmail', // or another email service
  auth: {
    user: 'your_email@gmail.com',
    pass: 'your_email_password',
  },
});

app.post('/api/auth/login', async (req, res) => {
  const { email, password } = req.body;
  try {
    const user = (await pool.query('SELECT * FROM users WHERE email = $1', [email])).rows[0];
    if (!user || !(await bcrypt.compare(password, user.password_hash))) {
      return res.status(401).json({ message: 'Invalid credentials' });
    }

    const otp = generateOtp();
    // Store OTP temporarily (e.g., in-memory or a dedicated table with an expiry)
    // For this example, let's use a simple in-memory object (not for production!)
    app.locals.otps = app.locals.otps || {};
    app.locals.otps[email] = otp;

    // Send OTP email
    const mailOptions = {
      from: 'your_email@gmail.com',
      to: email,
      subject: 'Your Investment Platform OTP',
      text: `Your One-Time Password is: ${otp}`,
    };
    transporter.sendMail(mailOptions, (error, info) => {
      if (error) {
        console.error('Error sending email:', error);
      } else {
        console.log('Email sent: ' + info.response);
      }
    });

    res.status(200).json({ message: 'OTP sent to your email.' });
  } catch (error) {
    res.status(500).json({ message: 'Server error' });
  }
});

app.post('/api/auth/verify-otp', async (req, res) => {
  const { email, otp } = req.body;
  if (app.locals.otps && app.locals.otps[email] === otp) {
    const user = (await pool.query('SELECT id, role, company_id FROM users WHERE email = $1', [email])).rows[0];
    const token = jwt.sign({ id: user.id, role: user.role, companyId: user.company_id }, 'YOUR_SECRET_KEY', { expiresIn: '1h' });
    delete app.locals.otps[email];
    return res.json({ token });
  }
  res.status(401).json({ message: 'Invalid OTP' });
});

app.post('/api/auth/forgot-password', (req, res) => {
  // Placeholder for password reset logic
  res.status(200).json({ message: 'Password reset link sent to your email.' });
});

// --- User Management API (Manager-only) ---
app.get('/api/manager/users', authenticateToken, authorizeRole('manager'), async (req, res) => {
  const { companyId } = req.user;
  try {
    const result = await pool.query('SELECT id, email, role FROM users WHERE company_id = $1 AND role = $2', [companyId, 'accountant']);
    res.json(result.rows);
  } catch (error) {
    res.status(500).json({ message: 'Server error' });
  }
});

app.post('/api/manager/users', authenticateToken, authorizeRole('manager'), async (req, res) => {
  const { email, password, role, legalEntities } = req.body;
  const { companyId } = req.user;
  try {
    const hashedPassword = await bcrypt.hash(password, 10);
    const result = await pool.query(
      'INSERT INTO users (email, password_hash, role, company_id) VALUES ($1, $2, $3, $4) RETURNING id',
      [email, hashedPassword, role, companyId]
    );
    const newUserId = result.rows[0].id;

    if (legalEntities && legalEntities.length > 0) {
      const assignments = legalEntities.map(entityId => `('${newUserId}', '${entityId}')`).join(',');
      await pool.query(`INSERT INTO accountant_assignments (user_id, legal_entity_id) VALUES ${assignments}`);
    }
    res.status(201).json({ message: 'User created successfully' });
  } catch (error) {
    res.status(500).json({ message: 'Server error' });
  }
});

app.put('/api/manager/users/:id/permissions', authenticateToken, authorizeRole('manager'), async (req, res) => {
  const { id } = req.params;
  const { legalEntities } = req.body;
  try {
    await pool.query('DELETE FROM accountant_assignments WHERE user_id = $1', [id]);
    if (legalEntities && legalEntities.length > 0) {
      const assignments = legalEntities.map(entityId => `('${id}', '${entityId}')`).join(',');
      await pool.query(`INSERT INTO accountant_assignments (user_id, legal_entity_id) VALUES ${assignments}`);
    }
    res.status(200).json({ message: 'Permissions updated successfully' });
  } catch (error) {
    res.status(500).json({ message: 'Server error' });
  }
});

// --- Dashboard & Reporting APIs ---
app.get('/api/manager/dashboard/kpis', authenticateToken, authorizeRole('manager'), async (req, res) => {
  const { companyId } = req.user;
  try {
    const totalEntities = (await pool.query('SELECT COUNT(*) FROM legal_entities WHERE company_id = $1', [companyId])).rows[0].count;
    const activeAccountants = (await pool.query('SELECT COUNT(*) FROM users WHERE company_id = $1 AND role = $2', [companyId, 'accountant'])).rows[0].count;
    const aum = (await pool.query('SELECT SUM(aum_value) FROM companies WHERE id = $1', [companyId])).rows[0].sum || 0;
    res.json({ totalEntities, activeAccountants, aum });
  } catch (error) {
    res.status(500).json({ message: 'Server error' });
  }
});

app.get('/api/manager/entities', authenticateToken, authorizeRole('manager'), async (req, res) => {
  const { companyId } = req.user;
  try {
    const result = await pool.query('SELECT * FROM legal_entities WHERE company_id = $1', [companyId]);
    res.json(result.rows);
  } catch (error) {
    res.status(500).json({ message: 'Server error' });
  }
});

app.get('/api/accountant/entities', authenticateToken, authorizeRole('accountant'), async (req, res) => {
  const { id } = req.user;
  try {
    const result = await pool.query(
      'SELECT le.* FROM legal_entities le JOIN accountant_assignments aa ON le.id = aa.legal_entity_id WHERE aa.user_id = $1',
      [id]
    );
    res.json(result.rows);
  } catch (error) {
    res.status(500).json({ message: 'Server error' });
  }
});

app.post('/api/accountant/journal-entries', authenticateToken, authorizeRole('accountant'), async (req, res) => {
  const { legalEntityId, description, transactions } = req.body;
  const { id } = req.user;
  
  const totalDebit = transactions.reduce((sum, t) => sum + (t.debit || 0), 0);
  const totalCredit = transactions.reduce((sum, t) => sum + (t.credit || 0), 0);

  if (totalDebit !== totalCredit) {
    return res.status(400).json({ message: 'Debits must equal credits.' });
  }

  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    const newEntry = (await client.query(
      'INSERT INTO journal_entries (date, legal_entity_id, description, created_by_user_id) VALUES (NOW(), $1, $2, $3) RETURNING id',
      [legalEntityId, description, id]
    )).rows[0].id;

    for (const t of transactions) {
      await client.query(
        'INSERT INTO transactions (journal_entry_id, account_name, debit, credit) VALUES ($1, $2, $3, $4)',
        [newEntry, t.accountName, t.debit, t.credit]
      );
    }

    await client.query('COMMIT');
    res.status(201).json({ message: 'Journal entry created successfully' });
  } catch (error) {
    await client.query('ROLLBACK');
    res.status(500).json({ message: 'Server error' });
  } finally {
    client.release();
  }
});

app.get('/api/reports/:type', authenticateToken, async (req, res) => {
  const { type } = req.params;
  const { entityId, start, end } = req.query;

  try {
    // Basic authorization check: ensure user has access to this entity
    const isAuthorized = await pool.query(
      'SELECT 1 FROM accountant_assignments WHERE user_id = $1 AND legal_entity_id = $2',
      [req.user.id, entityId]
    );
    if (isAuthorized.rows.length === 0 && req.user.role !== 'manager') {
      return res.status(403).json({ message: 'Access denied to this entity.' });
    }

    let reportData = [];
    switch (type) {
      case 'trial-balance':
        reportData = (await pool.query(`
          SELECT 
            account_name,
            SUM(debit) AS total_debits,
            SUM(credit) AS total_credits
          FROM transactions t
          JOIN journal_entries je ON t.journal_entry_id = je.id
          WHERE je.legal_entity_id = $1
          GROUP BY account_name
          ORDER BY account_name
        `, [entityId])).rows;
        break;
      case 'general-ledger':
        reportData = (await pool.query(`
          SELECT 
            t.id,
            je.date,
            je.description,
            t.account_name,
            t.debit,
            t.credit
          FROM transactions t
          JOIN journal_entries je ON t.journal_entry_id = je.id
          WHERE je.legal_entity_id = $1 AND je.date BETWEEN $2 AND $3
          ORDER BY je.date, t.id
        `, [entityId, start, end])).rows;
        break;
      default:
        return res.status(400).json({ message: 'Invalid report type' });
    }
    res.json(reportData);
  } catch (error) {
    res.status(500).json({ message: 'Server error' });
  }
});

// Start the server
app.listen(port, () => {
  console.log(`Backend server listening at http://localhost:${port}`);
});
